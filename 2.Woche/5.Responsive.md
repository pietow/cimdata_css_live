# 8. Responsive Design

> Learnziele
> Umsetzung von `mobile first`
> Breakpoints und media queries
> Flüssiges Layout

**Wiederholung**

- position: sticky
    - eine sticky box wird solang deer Elterncontainer im Viewport sichtbar ist
    nie den definierten Abstand (bsp. `top: 1em`) zum Viewport unterschreiten
- Reihenfolge, in der der Browser Html Elemente zeichnet:
    Elemente werden von Oben nach unten im Dom gezeichnet, das heißt
    - das erste element wird als erstes gezeichnet und somit vom nächsten element
    verdeckt
    - static Elemente werden immer zuerst gemalt, selbst wenn sie nach einem 
        - non-static Element im DOM vorkommen
    - allerdings können negative z-indices das betreffende non-static element unter static element verschieben

- `z-index` und `Stacking Kontext`:
    - wir haben ein z-Achse, die in die Seite hinein geht
        - hohe z-indices lassen Element höher erscheinen (überlappend)
        - niedriger z-index lässt die Element untenerscheinen (vereckend)
        - der erste z-index innerhalb eines verschachtelten HtmlElementes
            - beginnt einen `Stacking Kontext` innerhalb dieser Verschatelten 
                Html Struktur

- Bsp. Reihenfolge an verschieden Html elementen im html Dokument:
    1. position: absolute
    2. position: absolute
    3. position: relative, `z-index: -1`
        3. 2. position: absolute z-index: 10 (Kind)
    4. position: static

- Reihenfolge, die gezeichnet wird:
    3. position: relative, `z-index: -1`
        3. 2. position: absolute` z-index: 10` (Kind)
    4. position: static
    1. position: absolute
    2. position: absolute

- Extensionempfehlung:
    `Auto Rename Tag`

```html
<header id="header" class="page-header">
  <div class="title">
    <h1>Wombat Coffee Roasters</h1>
    <div class="slogan">We love coffee</div>
  </div>
</header>

<nav class="menu" id="main-menu">
  <button class="menu-toggle" id="toggle-menu">
    toggle menu
  </button>
  <!-- Adds the hamburger button for a mobile menu -->
  <div class="menu-dropdown">
    <!-- Main menu that will be hidden by default on mobile devices -->
    <ul class="nav-menu">
      <li><a href="/about.html">About</a></li>
      <li><a href="/shop.html">Shop</a></li>
      <li><a href="/menu.html">Menu</a></li>
      <li><a href="/brew.html">Brew</a></li>
    </ul>
  </div>
</nav>

<aside id="hero" class="hero">
  Welcome to Wombat Coffee Roasters! We are
  passionate about our craft, striving to bring you
  the best hand-crafted coffee in the city.
</aside>

<main id="main">
  <div class="row">
    <!-- Adds row and columns for medium and large viewports -->
    <section class="column">
      <h2 class="subtitle">Single-origin</h2>
      <p>We have built partnerships with small farms
        around the world to hand-select beans at the
        peak of season. We then carefully roast in
        <a href="/batch-size.html">small batches</a>
        to maximize their potential.
      </p>
    </section>

    <section class="column">
      <h2 class="subtitle">Blends</h2>
      <p>Our tasters have put together a selection of
        carefully balanced blends. Our famous
        <a href="/house-blend.html">house blend</a>
        is available year round.
      </p>
    </section>

    <section class="column">
      <h2 class="subtitle">Brewing Equipment</h2>
      <p>We offer our favorite kettles, French
        presses, and pour-over cones. Come to one of
        our <a href="/classes.html">brewing classes</a>
        to learn how to brew the perfect
        pour-over cup.
      </p>
    </section>
  </div>
</main>
```

* Der **Toggle-Button** für das mobile Menü liegt **innerhalb des `<nav>`** → logisch gruppiert, gute Semantik
* Die **`nav-menu`**-Liste ist so positioniert, dass sie **für mobile und Desktop** funktioniert
* **`row`** und **`column`** sind bereits vorbereitet → nötig für spätere Desktop-Layouts
* Man muss diese Struktur nicht von Anfang an perfekt kennen – typische iterative Entwicklung
* Nächster Schritt: **Grundstyles** setzen (Schrift, Überschriften, Farben)
* Beim Arbeiten auf **mobile Styles fokussieren** → Browserfenster schmal ziehen
* Zeigt sofort, wie Layout und Typografie auf kleinen Viewports wirken

```css
:root {
  box-sizing: border-box;
  font-size: calc(1vw + 0.6em); /*1 vw ist immer 1 % der Breite des sichtbaren Browserfensters.*/
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

body {
  margin: 0;
  font-family: Helvetica, Arial, sans-serif;
}

a:link {
  color: #1476b8;
  font-weight: bold;
  text-decoration: none;
}

a:visited {
  color: #1430b8;
}

a:hover {
  text-decoration: underline;
}

a:active {
  color: #b81414;
}

.page-header {
  padding: 0.4em 1em;
  background-color: #fff;
}
/* Page header and title */

.title > h1 {
  color: #333;
  text-transform: uppercase;
  font-size: 1.5rem;
  margin: 0.2em 0;
}

.slogan {
  color: #888;
  font-size: 0.875em;
  margin: 0;
}

.hero {
  padding: 2em 1em;
  text-align: center;
  background-image: url(coffee-beans.jpg);
  background-size: 100%;
  color: #fff;
  text-shadow: 0.1em 0.1em 0.3em #000;
}
/* Adds the hero image to the page */
/* A dark text shadow helps light text remain readable in front of complex background. */

main {
  padding: 1em;
}

.subtitle {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
  font-size: 0.875rem;
  text-transform: uppercase;
}
```


* Styles aus **Listing 8.2** hinzufügen

* **`:root`** ist der oberste Selektor im Dokumentbaum
* entspricht praktisch dem **`<html>`-Element**

* Danach folgen Grundstyles für:

  * **Header**
  * **Hauptbereich** (Body-Content)

* Zweck: stabile typografische Basis und konsistente Darstellung für das **mobile Layout** erstellen

* Styles sind einfach:

  * Titel + Untertitel werden **uppercase**
  * Margins und Padding ergänzen Abstände
  * Schriftgrößen für verschiedene Bereiche angepasst

* **text-shadow** im Hero-Bereich:

  * mehrere Werte bestimmen die Schattenwirkung
  * **0.1em 0.1em** → Verschiebung nach rechts und unten
  * **0.3em** → Blur-Radius (Weichzeichnung)
  * **#000** → Schattenfarbe (schwarz)

### Creating a mobile menu

* Jetzt kommt der **komplexeste Teil**: das Menü

 Menü funktioniert ähnlich wie das Dropdown aus Kapitel 7:

  * **`.menu-dropdown` ist anfangs versteckt**
  * Statt `:hover` kommt **JavaScript** ins Spiel
  * Klick auf `.menu-toggle` → Dropdown erscheint
  * erneuter Klick → Dropdown schließt sich

* Prinzip: **Mobile: Toggle-Menü**, später Desktop: **immer sichtbar, ohne Toggle**

* Screenreader nutzen bestimmte **HTML5-Landmarks**: `<form>`, `<main>`, `<nav>`, `<aside>`
* Dadurch können Nutzer mit Sehbehinderung **schnell springen** und sich orientieren
* Deshalb muss der **Menü-Button innerhalb des `<nav>`** liegen

  * sonst landet der Nutzer im Navigation-Landmark, findet aber **kein Menü**

* Im html code steht `<nav>` **unterhalb** vom `<header>` → beide sind **Geschwister**

* Dadurch fließt das Menü **unter den Header**, nicht hinein

* Design verlangt aber: **Hamburger-Button soll im Header sichtbar sein**

* Lösung:

  * **Absolute Positioning** für den `.menu-toggle`
  * Button wird optisch **nach oben gezogen**, obwohl er HTML-technisch im `<nav>` bleibt
  * Vorteil:

    * Semantik bleibt korrekt (Button im `<nav>`)
    * Design-Anforderung wird erfüllt (Button erscheint im Header)
```css
.menu {
  position: relative;
}
/* Establishes containing block for both absolutely positioned children */

.menu-toggle {
  position: absolute;
  top: -1.2em;
  right: 0.1em;
  /* A negative top pulls the button up outside its containing block. */
  border: 0;
  /* Overrides user agent button styles */
  background-color: transparent;
  font-size: 3em;
  width: 1em;
  height: 1em;
  line-height: 0.4;
  text-indent: 5em;
  white-space: nowrap;
  overflow: hidden;
  /* Hides the text content of the button and fixes its size at 1 em */
}

.menu-toggle::after {
  position: absolute;
  top: 0.2em;
  left: 0.2em;
  display: block;
  content: "\2261";
  /* Overlays the button with a unicode symbol, the hamburger icon */
  text-indent: 0;
}

.menu-dropdown {
  display: none;
  position: absolute;
  right: 0;
  left: 0;
  margin: 0;
}

.menu.is-open .menu-dropdown {
  display: block;
}
/* Displays the dropdown menu when the class is-open is added to the menu */
```

* Menü nutzt **position: relative** → schafft den *containing block* für

  * den absolut positionierten Toggle-Button
  * das absolut positionierte Dropdown

* Toggle-Button wird durch **negative top** nach oben gezogen

  * erscheint optisch im **Header**, obwohl er im `<nav>` liegt
  * `right: 0.1em` setzt ihn an den rechten Rand

* Button-Text wird versteckt durch Kombi aus:

  * feste Breite (1em)
  * sehr großer `text-indent`
  * `overflow: hidden`
    → Bildschirmleser sieht Text **toggle menu**, visuell sieht man ihn nicht

* `::after` erzeugt das Hamburger-Icon

  * `content: "\2261"` = Unicode mit drei horizontalen Linien
  * Positionierung über absolute Werte
  * Alternativ könnte man ein eigenes Icon per `background-image` verwenden

* Gute Möglichkeit zum Lernen: einzelne CSS-Zeilen auskommentieren → Effekte ansehen

  * besonders wichtig bei schmalem Viewport

* Neue Technik: **.is-open** Klasse

  * Wenn vorhanden → `.menu.is-open .menu-dropdown` zeigt das Dropdown
  * Wenn nicht vorhanden → Dropdown bleibt verborgen
  * Macht das Menü per JS *togglable*

```html
<script type="text/javascript">
(function () {
  var button = document.getElementById('toggle-menu');

  button.addEventListener('click', function(event) {

    var menu = document.getElementById('main-menu');
    menu.classList.toggle('is-open');
    /* Toggles is-open class on the menu */
  });
})();
</script>
```
* Hamburger-Klick öffnet jetzt das Dropdown
* erneuter Klick schließt es wieder
* **CSS übernimmt das Anzeigen/Verstecken**, JS ändert nur **eine Klasse** (`is-open`)
* Dropdown liegt sichtbar **über dem Inhalt** → korrektes Verhalten
* Nächster Schritt: **nav-menu stylen**
* Die dazugehörigen Styles sollen jetzt in das Stylesheet eingefügt werden


```css
.nav-menu {
  margin: 0;
  padding-left: 0;
  border: 1px solid #ccc;
  list-style: none;
  background-color: #000;
  color: #fff;
}
/* Styling the navigational menu */

.nav-menu > li + li {
  border-top: 1px solid #ccc;
}
/* Applies a border between each menu item */



.nav-menu > li > a {
  display: block;
  padding: 0.8em 1em;
  color: #fff;
  font-weight: normal;
}
/* Uses a healthy amount
of padding to ensure a
large clickable area */

```

* Menü ist ein `<ul>` → daher:

  * **linkes Padding entfernt**
  * **List-Punkte entfernt**

* **Adjacent sibling combinator (`li + li`)** →

  * trifft alle Items außer dem ersten
  * fügt **Trennlinie** zwischen den Punkten ein

* Wichtiger Punkt: **große Klickflächen**

  * `padding: 0.8em 1em` sorgt für gut tappbare Links
  * mobile Nutzer bedienen Elemente mit **Finger**, nicht mit Maus


**Tipp:**

* Alle wichtigen Bedienelemente **groß genug** machen
* Nutzer sollen **nicht zoomen müssen**, um ein kleines Element zu treffen

![This is just making fun of the fact that the x button in the ads are extremely small and it's impossible to close the add](image-43.png)

* Mobiles Design ist fertig, **aber** ein entscheidender Punkt fehlt
* Mobile Browser brauchen einen Hinweis, dass die Seite **für kleine Screens optimiert** ist
* Ohne diesen Hinweis nimmt der Browser an, die Seite sei **nicht responsive**
* Ergebnis ohne Meta-Tag: Browser zoomt heraus → Darstellung wie Desktop → **Mobile-Design wird ignoriert**
* Lösung: **Viewport-Meta-Tag** ins `<head>` einfügen

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```
* `content="width=device-width"`

  * Browser nutzt **tatsächliche Gerätebreite**
  * verhindert Desktop-Emulation auf kleinen Screens

* `initial-scale=1`

  * setzt **Start-Zoom auf 100 %**
  * Seite wird nicht heran- oder herausgezoomt geladen

* Es gibt weitere mögliche Optionen im `content`-Attribut, aber die üblichen Werte sind meist die besten

  * z. B. `width=320` → Browser tut so, als wäre der Viewport **immer 320px breit**

    * **nicht empfehlenswert**, da Geräte sehr unterschiedliche Breiten haben
    * `width=device-width` passt sich automatisch an

* Viele Entwickler setzen zusätzlich `user-scalable=no`

  * verhindert Zwei-Finger-Zoom
  * **schlechte Praxis**

    * Nutzer können Links, Buttons oder Bilder nicht vergrößern
    * erschwert Barrierefreiheit
    * frustriert Nutzer, wenn Inhalte klein oder schwer lesbar sind

## Media queries
  * ermöglichen Styles, die **nur unter bestimmten Bedingungen** gelten
  * typischer Einsatz: kleine, mittlere, große Viewports unterschiedlich stylen

* Syntax über **`@media` at-rule**

* Beispiel:

```css
@media (min-width: 560px) {
    .title > h1 {
        font-size: 2.25rem;
    }
}
```

* Bedeutung:

  * Styles gelten **nur**, wenn Viewport ≥ **560px**
  * sonst werden sie ignoriert

* Innerhalb der geschweiften Klammern können **beliebige Rulesets** stehen

* **Breakpoints sollten in `em` gesetzt werden**

  * einzige Einheit, die in **allen großen Browsern stabil** funktioniert

Beispiel (empfohlen):

```css
@media (min-width: 40em) {
  /* styles */
}
```

* Breakpoints **nicht in px**, sondern in **em** setzen

  * Grundlage: Standardbrowserfont meist **16px**
    * Umrechnung: `560px / 16 = 35em`

### media Query Typen

* Media Queries können **kombiniert** werden:

### **UND-Verknüpfung**

```css
@media (min-width: 20em) and (max-width: 35em) { … }
```

* gilt **nur**, wenn **beide** Bedingungen erfüllt sind
* Ziel: **konkreter Bereich** zwischen 20em und 35em

### **ODER-Verknüpfung**

```css
@media (max-width: 20em), (min-width: 35em) { … }
```

* Komma bedeutet **OR**
* gilt für **≤ 20em** **oder** **≥ 35em**
 Ziel: zwei getrennte Gruppen von Viewports ansprechen

 * **min-width / max-width**
* Ziel: Viewports **größer** oder **kleiner** als ein bestimmter Wert


* Weitere Media Features:

  * **(min-height: 20em)** → Viewports **≥ 20em Höhe**
  * **(max-height: 20em)** → Viewports **≤ 20em Höhe**
  * **(orientation: landscape)** → Geräte Breiter als hoch
  * **(orientation: portrait)** → Gerät Höher als breit
  * **(min-resolution: 2dppx)** → **Retina display / High-DPI** (3 dots per px)
  * **(max-resolution: 2dppx)** → bis 2 dppx


* **Media Queries im `<link>`-Tag**:

```html
<link rel="stylesheet" media="(min-width: 45em)" href="large-screen.css">
```

* Vorteil: **Code-Organisation**
Datei wird **immer heruntergeladen**, egal ob die Media Query zutrifft

**Medientypen**
* Media Queries können auch **Medientypen** ansprechen

  * Wichtigste Typen: **screen** und **print**

## **Print-Styles**

* Werden genutzt, wenn Benutzer die Seite **ausdrucken**
* Ziel: Druckversion **lesbar**, **tintenfreundlich** und **ohne unnötige Elemente** machen

 Beispiel:

```css
@media print {
  /* … */
}
```

* Häufige Maßnahmen:

  * **Navigation ausblenden** (`display: none`)
  * **Footer ausblenden**
  * **Backgrounds entfernen** (sparen Tinte)
  * **Schriftfarbe auf schwarz setzen**
  * optional größere Schrift oder andere Schriftarten für besseres Lesen

### Beispiel für universelle Druckbereinigung

```css
@media print {
  * {
    color: black !important;
    background: none !important;
  }
}
```
* `!important` wird bewusst genutzt, um die Druckstyles zuverlässig durchzusetzen
* Besonders sinnvoll für Seiten, die Nutzer **häufig drucken** (z. B. Rezepte)

### **Screen-Styles**

```css
@media screen {
  /* Styles nur für Bildschirm */
}
```

* Wird selten benötigt, weil Bildschirm ohnehin der Standard ist
* hilfreich, wenn man Screen und Print **klar trennen** möchte


### Breakpoints hinzufügen

* **Mobile First** bedeutet:

  * **Grundstyles zuerst** (für kleine Viewports)
   * danach **größere Breakpoints** hinzufügen → mit **min-width**

* Reihenfolge im Stylesheet (empfohlenes Muster):

```css
/* 1. Mobile Styles – Default */
body { … }
header { … }
nav { … }

/* 2. Medium Breakpoint */
@media (min-width: 35em) {
  /* Styles für mittlere Viewports */
}

/* 3. Large Breakpoint */
@media (min-width: 60em) {
  /* Styles für große Viewports */
}
```

* Dieses Muster ist der typische **mobile-first Workflow** für responsive CSS.

 **Warum min-width?**

  * mobile Styles funktionieren überall (kleinste gemeinsame Basis)
  * man erweitert Schritt für Schritt
  * bessere Performance → mobile Geräte laden nur wenige überschreibende Regeln
  * logischere Entwicklung: „aufbauen“ statt „zusammenstauchen“

  