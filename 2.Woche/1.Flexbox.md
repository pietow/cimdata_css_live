# 6. Display-Eigenschaft & Flexbox

> Learnziele
> - Block-Elemente vs. Inline-Elemente vs. Block-Inline
> - Flexbox (Layout)
>    - einfachere Anordnung von Html-Elementen (Box)
> - Eigenschaften wie Ausrichtung, Ausdehnung, Abstände in Flexbox

**Wiederholung**

1. Html
    - Semantisches Grundgerüst einer Website
    - Auszeichnungsprache
2. CSS
    - Design dieser Seite
    - Styling-Sprache
3. Javascript
    - Interaktion/Verhalten dieser Seite
    - Programmiersprache, da wir Logik verwenden können, Funktionen und Schleifen haben 

Semantische Elemente:
- main
- aside
- nav
- h1-h6
Warum sollten wir nicht nur div container verwenden, obwohl wir nur über CSS das Design kontrollieren sollten?
1. Es fehlt an inhaltlicher Struktur und somit an Übersicht
2. Screenreader brauchen diese Strukturen, um effizient zu arbeiten; mit erhöhen wir die Barrierefreiheit
3. Die Verwendung von bestimmten Html tags ist auch für die SEO wichtig
    - in h1 und title suchen Suchmaschinen nach Schlüßelworte, die dann das Ranking der Seite mitbestimmen
- h1-h6 (es sollte keine Übschriftebene übersprungen werden z.b. von h2 zu h4); relevant für screenreader
- Grafikformate
    - jpeg
    - gif
    - webp: moderneres Grafikformat: komprimierter als bsp. jpeg bei gleicher Qualität
    - avif: neuste Format
    - png
    - svg: Skalierung ohne Qualitätsverlust 
- Box-Model
    - Margin, Border, Padding, Content
    - Breite: (Default) durch Content bestimmt (- `box-sizing: content-box`)
    - `box-sizing: border-box` --> die Breite wird bestimmt durch Content und Padding, Border 
- Normalizierung der CSS Standardeigenschaften:
    - globales Setzten von CSS-Eigenschaften:
        Universal-Selektor: *
**Bsp**

```css
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
```
    - Reduktion von CSS-Code

- CSS-Selektoren
    1. Klassen-Se.
        - .my_class
    2. Attr.-Se.
        - [attributname=attributwert]
    3. Id-Se.
        - #container-id
    4. Tag-Sel
        - p
        - ul
        - div etc.
    5. Direkte nachfahren
        - ul.my-class > li (direkten Listelement-Nachfahren von ul.my-class)
        ```html
        <ul class="my-class">
            <li>Item<li>
            <li>
                <li>Item<li>
                <li>Item<li>
            </li>
            <li>Item<li>
            <li>Item<li>
        </ul>
        ```
    6. alle Nachfahren
        - ul.my-class li (alle Listelement-Nachfahren von ul.my-class)
    7. Auf ein Element folgendes Geschwisterelement
        - h3 + p (p wird nur ausgewählt, falls es unmittelbar einem h3 folgt) 
    
https://pe.app/response_links/331b8adb-6737-4ab8-bfa0-26c555720e41 (Box Model)

## **Block-Elemente – mit HTML-Beispiel**

* Block-Elemente erzeugen eine neue Box, nehmen die volle Breite ein und beginnen in einer neuen Zeile.
* Sie können Text und weitere HTML-Elemente enthalten.
* Beispiele: `<div>`, `<p>`, `<h1>`–`<h6>`, `<ul>`, `<ol>`, `<li>`, `<blockquote>`, `<form>`, `<table>`, `<footer>`.
* Sie strukturieren Inhalte der Seite.

## Inline-Elemente – mit HTML-Beispiel

* Inline-Elemente erzeugen keinen Zeilenumbruch.
* Sie benötigen nur den Platz, den ihr Inhalt benötigt.
* Sie werden innerhalb von Textabschnitten eingesetzt.
* Beispiele: `<span>`, `<a>`, `<strong>`, `<em>`, `<img>`, `<input>`, `<button>`, `<label>`.

## CSS-Eigenschaft display 

* `display` bestimmt das Layout-Verhalten eines Elements.
* `block` → Block-Element
* `inline` → Inline-Element
* Viele HTML-Elemente sind bereits standardisiert und benötigen keine Umdefinition.

##  display: inline-block

* `inline-block` kombiniert Inline- und Block-Eigenschaften.
* Elemente stehen nebeneinander (wie inline).
* Nimmt nur so viel Breite, wie sein Inhalt braucht.
* Aber: Breite und Höhe können ebenfalls gesetzt werden (anders als bei inline).
* Besonders geeignet für Navigationen, Buttons, kleine Layout-Bausteine.

## **Flexbox **


### **Einführung**


* Flexbox („Flexible Box Layout“) ist eine moderne Methode, Elemente auf Webseiten zu layouten.
* Bietet **vorhersehbarere** und **präzisere Kontrolle** als Floats.
* Löst klassische Probleme wie **vertikale Zentrierung** und **gleich hohe Spalten**.

### **Browserunterstützung**

* Flexbox existiert seit mehreren Jahren und wird inzwischen von **allen großen Browsern** unterstützt.

### **Komplexität**

* Flexbox bringt **12 neue CSS-Eigenschaften** (inkl. Shorthands).
* Kann anfangs überwältigend wirken
* Man muss **nicht alle 12** auswendig kennen – wenige zentralen Eigenschaften reichen für den Anfang.

### **Ziel**

* Was Flex-Container und Flex-Items sind
* Hauptachse (main axis) und Querachse (cross axis)
* Größenberechnung in Flexbox
* Ausrichtung von Elementen

## **Grundprinzipien von Flexbox**

* Flexbox startet mit der bekannten Eigenschaft **display**.
* **display: flex**:

  * Das Element wird zum **Flex-Container**.
  * Seine **direkten Kinder werden Flex-Items**.

* Standardverhalten:
    * Flex-Items erscheinen **nebeneinander** (links nach rechts).
    * Der Flex-Container nimmt **volle Breite** ein (wie ein Blockelement).
    * Flex-Items müssen nicht die gesamte Breite ausfüllen.
    * Alle Flex-Items haben **gleiche Höhe**, bestimmt durch ihren Inhalt.

### **display: inline-flex**

* Erzeugt ebenfalls einen Flex-Container, aber
    * Verhält sich eher wie ein **inline-block-Element**.
    * Läuft inline mit anderen Elementen.
    * Wächst **nicht automatisch auf 100% Breite**.
* Die Flex-Items darin verhalten sich ansonsten wie bei display: flex.

### **Unterschied zu früheren display-Werten**

* Klassische Werte (inline, block, inline-block ...) beeinflussen nur das **Element selbst**.
* Ein **Flex-Container steuert aktiv das Layout seiner Kinder**.
* Der Container entscheidet also über Ausrichtung, Größe und Verhalten der Flex-Items.

![Flex container](<shapes at 25-11-17 10.47.12.svg>)

### **Ausblick / Anwendung**

![Ziel-Layout](<shapes at 25-11-17 10.52.16.svg>)

* Die Seite ist so aufgebaut, dass **verschiedene Flexbox-Techniken** gezeigt werden.
* Flexbox wird verwendet für:
    * das **Navigationsmenü oben**
    * die **drei weißen Boxen** im Inhalt
    * den **$20.00-Text** unten rechts als Stilelement

**`flex`-Property**

  * **column-main** → **2/3 der Breite**
  * **column-sidebar** → **1/3 der Breite**

* Dafür wird in den CSS-Regeln `flex` verwendet.

* Flexbox übernimmt die **Berechnung automatisch**.

```css
.item {
    flex: 1
}
```

* Die Eigenschaft **`flex`** ist eine **Shorthand-Property** für drei Einzelwerte:

 * **flex-grow**
  * **flex-shrink**
  * **flex-basis**

* Das bedeutet:

  * `flex: 2` entspricht **`flex: 2 1 0%`**.

* **flex-basis** legt eine **Ausgangsgröße** für ein Flex-Item fest

![flx grow](<shapes at 25-11-17 11.48.24.svg>)

* Nachdem **flex-basis** die **Ausgangsgröße** eines Flex-Items festgelegt hat, muss der verfügbare Platz im Flex-Container eventuell **neu verteilt** werden.

* Die Items können daher **größer** oder **kleiner** werden müssen, um in die Hauptachse (main axis) zu passen.

* Genau dafür gibt es zwei Eigenschaften:

  * **flex-grow** → bestimmt, **wie stark ein Item wächst**, wenn **Platz übrig** ist.
  * **flex-shrink** → bestimmt, **wie stark ein Item schrumpft**, wenn **zu wenig Platz** vorhanden ist.

### Flex-grow

* **flex-grow** ist eine **nicht-negative ganze Zahl** (0, 1, 2, …).
* Ein Item mit **flex-grow: 0** → wächst **nicht über seine Basisgröße hinaus**.
  * Ein Item mit **flex-grow: 1 oder höher** → wächst, um freien Platz auszunutzen.
* Haben mehrere Items ein Wachstum > 0, wird der Restplatz 
**proportional** verteilt.