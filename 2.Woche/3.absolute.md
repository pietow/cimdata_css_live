# 8. Flex & Positions

> Learnziele
> - ausgewählte Flex Eigenschaften im live code anwenden
> - Einführung Position
>   - static
>   - absolute
>   - relative
>   - fixed
>   - sticky
>   - z-index

**Wiederholung**

- Flexbox

```html
<div class="flex_container">
    <div class="item1">Box</div>
    <div class="item">Box</div>
    <div class="item">Box</div>
    <div class="item">Box</div>
</div>
```

```css
.flex_container {
    display:flex;
    width: 100%:
}

.item1 {
    flex-grow: 1 /*Flex Container Elementeigenschaften*/
}
```

1. Flex Container Eigenschaften: 100%
    - `align-items`: (entlang der Querachse)
        1. flex-start
        2. flex-end
        3. center
        4. baseline
        5. stretch
    - `justify-content`: (entlang der Hauptachse)
        1. flex-start
        2. flex-end
        3. center
        4. space-between 
        5. space-around
    - `align-content`: (nur wenn, `flex-wrap: wrap`)
        1. flex-start
        2. flex-end
        3. center
        4. space-between 
        5. space-around
    -  `flex-wrap`
        1. wrap
        2. nowrap
        3. wrap-reverse

    - `flex-direction`:
        - row (row-reverse)
        - column (column-reverse)
    -     
2. Flex Container Elementeigenschaften
    - `flex-grow`
        - Wachstumsfaktor des Elements
    - `flex-shrink`
        - Schrumpffaktor
    - `flex-basis`
        - Breite des Elements
    - `align-self`:
        1. flex-start
        2. flex-end
        3. center
        4. baseline
        5. stretch
    - `order`: ändert die Reihenfolge der Elemente 

![align-self versus align-items](<shapes at 25-11-19 08.56.49.svg>)


### Ausrichtungs-Eigenschaften verwenden

```css
.centered {
  text-align: center;
}

.cost {
  display: flex;
  justify-content: center;
  align-items: center;
  line-height: .7;
}

.cost > span {
  margin-top: 0;
}

.cost-currency {
  font-size: 2rem;
}

.cost-dollars {
  font-size: 4rem;
}

.cost-cents {
  font-size: 1.5rem;
  align-self: flex-start;
}

.cta-button {
  display: block;
  background-color: #cc6b5a;
  color: white;
  padding: .5em 1em;
  text-decoration: none;
}
```

* Der Code erstellt die **Flexbox für die Darstellung von `$20.00`**, zusätzlich:

  * `.centered` → zentriert den restlichen Text
  * `.cta-button` → Styles für den Call-to-Action-Button

* Die einzige ungewöhnliche Deklaration ist **`line-height: .7`**:

  * Grund: Die **Zeilenhöhe** bestimmt bei Flex-Items die **Höhe des Elements**.
  * Standard-Zeilenhöhe (z. B. 1em) ist höher als die tatsächlichen Zeichen, weil sie **Platz für Unterlängen** (descenders) vorsieht.
  * Die Ziffern und das Dollarzeichen haben **keine Unterlängen**, sie sind also tatsächlich **etwas niedriger als 1em**.
  * Dadurch schien der vertikale Abstand zu groß.

* Der Wert `.7` ist **durch Ausprobieren** entstanden, bis die vertikale Ausrichtung perfekt aussah.

  * Flexbox reagiert hier sehr sensibel auf Zeilenhöhe, weil jedes `<span>` dadurch mehr oder weniger Platz auf der Kreuzachse bekommt.

## Probleme mit Flexbox

* Flexbox berechnet die **Größen der Flex-Items dynamisch**, abhängig von:

  * Anzahl der Flex-Items
  * Inhalt jedes Items
  * verfügbarem Platz im Container

* Dadurch kann bei **großen Seiten** oder **langsamer Verbindung** ein ungewöhnlicher Effekt auftreten:

  **Problem:**

  * Der Browser rendert Inhalte **progressiv**, während er sie lädt.
  * Beispiel: 3-Spalten-Layout mit `flex-direction: row`.
  * Wenn nur die ersten **zwei Spalten** geladen sind, werden sie sofort angezeigt.
  * Später lädt die dritte Spalte → Flexbox berechnet **alle Spalten neu**.
  * Ergebnis:

    * Nutzer sieht **kurz ein 2-Spalten-Layout**
    * anschließend **sprungartige Größenänderung**, wenn die dritte Spalte erscheint

* Dieses Verhalten wird im Artikel von **Jake Archibald** beschrieben:
  [https://jakearchibald.com/2014/dont-use-flexbox-for-page-layout/](https://jakearchibald.com/2014/dont-use-flexbox-for-page-layout/)
  (Beispiele siehe dort)

* **Empfehlung aus dem Artikel:**

  * Für **vollständige Seiten-Layouts** mit mehreren Spalten → lieber **CSS Grid** verwenden
  * Grid ist stabiler, da es Layouts **nicht vom Ladezustand einzelner Inhalte** abhängig macht

* **Wichtig:**

  * Dieses Problem betrifft **nur mehrere Spalten nebeneinander** (`flex-direction: row`).
  * Bei **mehreren Reihen übereinander** (`flex-direction: column`) tritt es **nicht** auf.

https://pe.app/response_links/aaacb38c-6b2d-4bbb-9baf-d313020ee593 (Flex )

# **Position – Layout**

* positionierte Elemente können aus dem Dokumentfluss genommen werden

**Typen der Positionierung**

**relative**
Bleibt im Fluss, verschiebt sich relativ zu seiner normalen Position.
Wird oft als Bezugspunkt für absolute Elemente genutzt.

**absolute**
Wird aus dem Fluss entfernt.
Positioniert sich relativ zum **nächsten positioned ancestor**.
Perfekt für Dropdowns, Tooltips

**fixed**
Gebunden an den **Viewport**.
Ideal für Modals oder feste Header.

**sticky**
Wechselt von relativ zu fest, sobald eine definierte Scrollgrenze erreicht wird.
Gut für navigierende Überschriften und Inhaltsverzeichnisse.

**Stacking Context**

Ein unsichtbarer Ebenen-Kontext, der entscheidet, wie Elemente übereinander liegen.
Wichtig, um z-index-Probleme zu verstehen und zu vermeiden.

- Flexbox/Grid steuern Layout im Dokumentfluss.
- Positionierung entfernt Elemente teilweise oder komplett aus dem Fluss.
Mit z-index + stacking context bestimmst du, was vorne und hinten liegt.

**Fixed Positioning**

*  `position: fixed` bindet ein Element fest an den Viewport.
* `top, right, bottom, left` bestimmen den Abstand zu den Viewporträndern.
* Beispiel: top: 3em → Element liegt 3 em unter der Oberkante des Viewports.
* Setzt man links + rechts, ergibt sich die Breite automatisch (Viewportbreite minus diese Abstände).
* Gleiches gilt für oben + unten und die Höhe.

**Bsp.: Modal mit Fixed Positioning**

* Ein Modal liegt vor dem Seiteninhalt und blockiert Interaktion.
* Wird meist mit zwei Elementen gebaut: Overlay + Dialogbox.
* Overlay überdeckt ganze Seite (position: fixed).
* Dialogbox ebenfalls fixed, meist zentriert.
* Modal ist zuerst unsichtbar (`display: none`).
* Wird per JavaScript eingeblendet (`display: block`).

```html
<header class="top-banner">
  <div class="top-banner-inner">
    <p>
      Find out what's going on at Wombat Coffee each month. Sign up for our newsletter:
      <button id="open">Sign up</button>
    </p>
  </div>
</header>

<div class="modal" id="modal">
  <div class="modal-backdrop"></div>
  <!-- A “backdrop” to obscure content behind the modal -->
  <div class="modal-body">
    <button class="modal-close" id="close">close</button>
    <h2>Wombat Newsletter</h2>
    <p>Sign up for our monthly newsletter. No spam. We promise!</p>
    <form>
      <p>
        <label for="email">Email address:</label>
        <input type="text" name="email"/>
      </p>
      <p><button type="submit">Submit</button></p>
    </form>
  </div>
</div>

<script type="text/javascript">
  var button = document.getElementById('open');
  var close = document.getElementById('close');
  var modal = document.getElementById('modal');

  button.addEventListener('click', function(event) {
    event.preventDefault();
    modal.style.display = 'block';
  });

  close.addEventListener('click', function(event) {
    event.preventDefault();
    modal.style.display = 'none';
  });
</script>
```

## Absolute positioning

* Funktioniert genauso wie fixed – aber mit einem anderen **containing block**.
* Der containing block ist der **nächste Vorfahr**, der **positioned** ist (also nicht static).
* top, right, bottom, left beziehen sich dann auf diesen Vorfahren, nicht auf den Viewport.

* fixed → immer relativ zum **Viewport**
* absolute → relativ zum **nächsten positioned ancestor**

# Positioning a pseudo-element

* Der Close-Button soll statt des Wortes **close** ein grafisches **×** anzeigen.

* Das Wort darf aber **nicht aus dem HTML entfernt** werden, da Screenreader es benötigen.

* Lösung:

    * Button-Text **optisch ausblenden**, aber im HTML belassen.
    * Mit **overflow: hidden** und einer großen **text-indent** den Text aus dem sichtbaren Bereich schieben.
    * Mit **::after** ein **×** einfügen (besser das Unicode-Multiplikationszeichen).
    * escaped unicode number: `\00D7`.
    * Das × wird über **absolute positioning** im Button zentriert.

```css
.modal-close {
  position: absolute;
  top: 0.3em;
  right: 0.3em;
  padding: 0.3em;
  cursor: pointer;
  font-size: 2em;
  height: 1em;
  width: 1em;
  text-indent: 10em;
  overflow: hidden;
  border: 0;
}

.modal-close::after {
  position: absolute;
  line-height: 0.5;
  top: 0.2em;
  left: 0.1em;
  text-indent: 0;
  content: "\00D7";
}
```



* Der Button wird auf **1em × 1em** festgelegt, damit er ein kleines Quadrat bildet.
* **text-indent** verschiebt den sichtbaren Text weit nach rechts aus dem Element hinaus.
* Der genaue Wert ist egal, Hauptsache größer als die Buttonbreite.
* Da text-indent vererbt wird, muss es im **::after**-Pseudo-Element wieder auf **0** gesetzt werden, damit das × nicht mit verschoben wird.
* Das **::after** verhält sich wie ein absolut positioniertes Kind des Buttons.
* Weil der Button positioned ist, wird er zum **containing block** des Pseudo-Elements.
* Eine kleine **line-height** verhindert, dass das Pseudo-Element zu hoch wird.
* Mit **top** und **left** wird das × im Button zentriert; die genauen Werte sind Feintuning.
* Absolute Positionierung ist sehr mächtig und wird häufig für Menüs, Tooltips und Info-Boxen genutzt.
* Für Dropdown-Menüs wird absolute Positionierung meist zusammen mit **relative positioning** des Eltern-Elements verwendet.

## Relative positioning

* **position: relative** führt zunächst zu **keiner sichtbaren Veränderung**.
* Das Element bleibt an seinem ursprünglichen Platz im Dokumentfluss.
* Auch die umliegenden Elemente bleiben unverändert an ihren Positionen.
* Erst wenn **top, right, bottom oder left** gesetzt werden, verschiebt sich das Element **von seinem ursprünglichen Standort aus**.
* Wichtig: Die **Umgebung reagiert nicht** auf diese Verschiebung.
* Die anderen Elemente orientieren sich weiterhin an der **ursprünglichen Position**, nicht an der verschobenen.
* Beispiel: Ein Element mit `top: 1em; left: 2em` wird sichtbar nach unten und rechts verschoben, aber die Nachbarelemente tun so, als wäre es noch am alten Platz.
* Relative Positionierung wird häufig verwendet, um einen **Bezugspunkt** für absolut positionierte Kinder zu schaffen.

![2. Element verschoben durch relative Positionierung](<shapes at 25-11-19 11.30.28.svg>)

* Negative Werte sind erlaubt, z. B. `bottom: -1em` → verschiebt ebenfalls **1em nach unten**, ähnlich wie `top: 1em`.

* Im Gegensatz zu **absolute** und **fixed** kann man mit relative **keine Größen** bestimmen:
* top/bottom können **nicht gleichzeitig** verwendet werden (bottom wird ignoriert).
* left/right ebenfalls nicht gleichzeitig (right wird ignoriert).
* Diese Werte beeinflussen **nur die Verschiebung**, nicht Breite oder Höhe.

* Das Verschieben per relative ist manchmal hilfreich, um ein Element leicht „anzuschubsen“.

* Der Hauptzweck von `position: relative` ist jedoch ein anderer:

* Es dient meist dazu, einen **containing block** für **absolut positionierte Kindelemente** zu schaffen.

## Creating a dropdown menu

* Jetzt soll ein **Dropdown-Menü** mit **relative + absolute positioning** gebaut werden.
* Das Menü besteht anfangs aus einem einfachen Rechteck.
* Wenn der Benutzer mit der Maus darüber fährt (**:hover**), öffnet sich eine Liste von Links (Dropdown).
* Das Dropdown erscheint **über dem restlichen Seiteninhalt**, also davor in der visuellen Ebene.

* Das Markup **nach dem Modal-Container** eingefügt (nach `</div>` von `.modal`):
```html
<div class="container">
  <nav>
    <div class="dropdown">
      <div class="dropdown-label">Main Menu</div>
      <div class="dropdown-menu">
        <ul class="submenu">
          <li><a href="/">Home</a></li>
          <li><a href="/coffees">Coffees</a></li>
          <li><a href="/brewers">Brewers</a></li>
          <li><a href="/specials">Specials</a></li>
          <li><a href="/about">About us</a></li>
        </ul>
      </div>
    </div>
  </nav>
  <h1>Wombat Coffee Roasters</h1>
</div>
```

```css
.container {
  width: 80%;
  max-width: 1000px;
  margin: 1em auto;
}

.dropdown {
  display: inline-block;
  position: relative;
}

.dropdown-label {
  padding: .5em 1.5em;
  border: 1px solid #ccc;
  background-color: #eee;
}

.dropdown-menu {
  display: none;
  position: absolute;
  left: 0;
  top: 2.1em;
  min-width: 100%;
  background-color: #eee;
}

.dropdown:hover .dropdown-menu {
  display: block;
}

.submenu {
  padding-left: 0;
  margin: 0;
  list-style-type: none;
  border: 1px solid #999;
}

.submenu > li + li {
  border-top: 1px solid #999;
}

.submenu > li > a {
  display: block;
  padding: .5em 1.5em;
  background-color: #eee;
  color: #369;
  text-decoration: none;
}

.submenu > li > a:hover {
  background-color: #fff;
}
```
* Der **Dropdown-Container** hat `position: relative`; dadurch entsteht der **containing block** für das absolut positionierte Menü.
* Das Menü (`.dropdown-menu`) ist anfangs **versteckt** (`display: none`).
* Mit `position: absolute`, `left: 0` und `top: 2.1em` erscheint das Menü **direkt unter dem Label** und linksbündig mit dem Label.
* `min-width: 100%` sorgt dafür, dass das Dropdown **mindestens so breit** ist wie der Container (Breite wird vom Label bestimmt).
* `.dropdown:hover .dropdown-menu` zeigt das Menü an, solange sich der Mauszeiger **über dem gesamten Dropdown** befindet (Label oder Menü).
* `submenu` gestaltet die einzelnen Listenelemente, inklusive Trennlinien und Hover-Effekten.
* Öffnet man jetzt das Modal, kann es **hinter** dem Dropdown erscheinen — ein **z-index/stacking-context**-Problem, das später behandelt wird.