# 2. Flexbox II

> Lernziele
> - Flex-Shrink
> - weiter Eigenschaften von Flexbox
> - Steuerung der Ausrichtung von Flex items
>    1. über Container
>    2. über individulle Flex items 

**Wiederholung**

- Block und Inline Elemente
    - Blockelemente beginnen ein neue Zeile
    - es können CSS Breiten (width) auf Blockelemente definiert werden
    - standardmäßis füllt ein Block Element 100% des Platzes des Elterncontainers
    - es können keine CSS Breiten (width) auf Inline-elemente definiert werden
    - Inline Elemente rufen keinen Zeilenumbruch hervor
    - Die Breite von Inline Elementen ist durch deren Inhalt bestimmt

- Blockelemente:
    - p, div, main, ascide, nav etc.
- Inlineelemente:
    - span, em, strong, i, b etc.

- Inline-Block elemente:
    - erhalten ihre länge aber rufen einen neue Zeilenumbruch hervor

- wir können die Blockeinstellung über CSS verändern:
    - `display: block`
    - `display: inline`
    - `display: inline-block`
- display: flex --> block flex element (container)
- display: inline-flex -> inline flex element (container)  

![Flexcontainer und verschachtelte Flexboxen](<shapes at 25-11-18 08.53.10.svg>)

**Flex grow**

* Ein höherer **flex-grow**-Wert gibt einem Flex-Item **mehr Gewicht**.
* Es erhält dadurch **einen größeren Anteil** des verbleibenden freien Platzes


* **flex-grow: 2** wächst **doppelt so stark** wie **flex-grow: 1**.
![flex grow 2 vs. 1](<shapes at 25-11-18 09.06.29.svg>)

* Die Kurzschreibweisen **`flex: 2`** und **`flex: 1`** entsprechen intern:

* **flex-grow:** 2 bzw. 1
* **flex-shrink:** 1
* **flex-basis:** **0%**

* Durch **flex-basis: 0%** starten beide Spalten mit **0 Breite**.

* Dieser verbleibende Raum wird dann gemäß **grow-Faktoren** verteilt:

    * Die linke Spalte (`flex: 2`) erhält **2 Anteile**
    * Die rechte Spalte (`flex: 1`) erhält **1 Anteil**

* Ergebnis:

  * **2/3 der Breite** gehen an `.column-main`
  * **1/3 der Breite** gehen an `.column-sidebar`

**Tip:**

* Es ist empfehlenswert, **die Kurzschreibweise `flex`** zu verwenden, statt **flex-grow**, **flex-shrink** und **flex-basis** einzeln zu deklarieren.

* Bei dieser Shorthand gilt eine wichtige Besonderheit:

  * Nicht gesetzte Werte werden **nicht** auf ihre CSS-Initialwerte gesetzt.
  * Stattdessen vergibt die Shorthand automatisch **sinnvolle Standardwerte**:

 * **flex-grow: 1**
  * **flex-shrink: 1**
  * **flex-basis: 0%**

* Diese Defaults entsprechen in den meisten Fällen genau dem, was man im Flexbox-Layout benötigt.

### flex-shrink

* **flex-shrink** funktioniert nach dem gleichen Prinzip
    * aber in die **entgegengesetzte Richtung**
* Nachdem die **anfängliche Breite (main size)** der Flex-Items festgelegt wurde, kann es passieren, dass die Items **mehr Platz benötigen**, als der Flex-Container zur Verfügung hat.
 Ohne **flex-shrink** würden die Elemente dann **überlaufen** – also aus dem Container herausragen


![Overflow mit flex-shrink](<shape__DlYpuEgtTs4uYLeNhDjl at 25-11-18 09.31.04.svg>)
![flex shrink > 0](<shapes at 25-11-18 09.29.52.svg>)



### Praktische Anwendungsbeispiele

  **1. Proportionale Spalten**
  * Über **`flex-grow`** (z. B. 2:1)
  * Oder über **`flex-basis`** in Prozent (z. B. 66.67% / 33.33%)

  **2. Kombination aus festen Breiten und „fluiden“ Spalten**
  * Eine Spalte hat z. B. **feste px-Breite**
  * Die andere ist **flexibel** und wächst mit dem verfügbaren Platz

**3. Grid-Systeme**
* Flexbox macht Grids einfacher und stabiler als Float-Hacks

**4. Gleich hohe Spalten**

* Flexbox macht Spalten **automatisch gleich hoch**, basierend auf ihrem Inhalt
* Mit Floats war das früher nur mit **komplizierten, fehleranfälligen Tricks** möglich
 * Flexbox löst das sofort und zuverlässig

**5. „Holy Grail Layout“ (klassische 3-Spalten-Struktur)**

* Zwei Sidebars mit **fester Breite** links und rechts
* Eine **mittlere Spalte, die flexibel wächst**
* Dieses Layout galt lange als eines der schwierigsten in CSS
* Flexbox macht es **sehr einfach** umzusetzen

![Layouts mit Flexbox](<shapes at 25-11-18 09.46.18.svg>)

### Flex direction

* Flexbox erlaubt es, die **Ausrichtung der Achsen zu ändern**.
* Dafür ist die Eigenschaft **`flex-direction`** zuständig, die auf den **Flex-Container** angewendet wird.

* **Standardwert:** `row`
    * Die Flex-Items laufen **von links nach rechts**.

* Alternative Werte:

  * `column` → Items stapeln sich **von oben nach unten**.
  * `row-reverse` → **rechts nach links**.
  * `column-reverse` → **unten nach oben**.

* Wichtiger Grundsatz bei vertikalen Flexboxen:

* In CSS ist **Höhe** grundsätzlich anders als Breite.
* Ein Flex-Container wird automatisch **100 % breit**, aber seine **Höhe entsteht durch den Inhalt**.
  * Das bleibt auch bei `flex-direction: column` so.
* Konsequenz daraus:

  * **flex-grow** und **flex-shrink** in einer vertikalen Flexbox wirken **nur**, wenn die Höhe des Containers **durch etwas Äußeres festgelegt** wird.


### Login Formular:Styling

* Das grobe Seitenlayout ist jetzt vollständig umgesetzt.
* Als Nächstes werden die **kleineren Elemente** in der rechten Spalte gestylt:

* Das `<form>` hat die Klasse **login-form** und wird damit im CSS gezielt angesprochen.
* Das folgende CSS stylt **drei Bereiche**: Überschrift, Eingabefelder, Button.

---

```css
.login-form h3 {
  margin: 0;
  font-size: .9em;
  font-weight: bold;
  text-align: right;
  text-transform: uppercase;
}

.login-form input:not([type=checkbox]):not([type=radio]) {
  display: block;
  width: 100%;
  margin-top: 0;
}

.login-form button {
  margin-top: 1em;
  border: 1px solid #cc6b5a;
  background-color: white;
  padding: .5em 1em;
  cursor: pointer;
}
```

---

* **Überschrift (`h3`)**

  * Kein Margin
  * Kleine Schrift
  * Fett
  * Rechtsbündig
  * Alles in Großbuchstaben per `text-transform`
  * HTML bleibt normal geschrieben (Trennung von Inhalt & Darstellung)

* **Input-Felder**

  * Der Selektor schließt **Checkboxen** und **Radiobuttons** aus

    * `:not()` + `[type=checkbox]` + `[type=radio]`
    * Grund: `<input>` wird für sehr unterschiedliche Inputs verwendet
  * Blacklist-Ansatz: Alle Inputs außer Checkbox/Radio werden gestylt
  * Alternativ wäre Whitelist (alle gewünschten Typen einzeln), aber länger
  * `display: block` → jedes Input auf eigener Zeile
  * `width: 100%` nötig, weil `<input>` sonst Breite nach `size` bestimmt

* **Button**

  * Einfaches visuelles Styling
  * `cursor: pointer` sorgt für den „Hand“-Cursor

    * Signalisiert, dass der Button klickbar ist
    * Letzter kleiner UX-Feinschliff

## Weitere Flex Eigenschaften

![flex content Eigenschaften](<shapes at 25-11-18 11.17.02.svg>)

![Flex Item Eigenschaften](<shapes at 25-11-18 11.45.43.svg>)

