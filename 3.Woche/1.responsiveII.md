# 9. Responsive Design II

> Learnziel
> - mediaqueries mit Flexbox
>   - medium und large Screens

**Wiederholung**

1. Box model:
    - content, padding, border, margin
    - `box-sizing`
    - CSS-Eigenschaft, die bestimmt was von einer Box zur Breite hinzugezählt wird
        - content-box: nur der content bestimmt die Breite
        - border-box: content, padding und border bestimmen die Beite

2. Flexbox:
    - bestimmte Zuteilung der Kinderelemente  
    - vereinfacht die Positionierung von Kinderelement und somit ist es auch
    einfach eine Layout für eine Seite zu gestallten

![Flexbox Wdh.](<shapes at 25-11-24 09.08.09.svg>)

3. Position
    css-Eigenschaft

    - `position`:   `relative`
        - die ursprüngliche Position des relativen Elements 
            bleibt im Dokumentenfluss erhalten, d.h. nachfolgen Elemente verrücken sich nicht
        - mit top, bottom, left und right können wir das Element relative zur ursprüngliche Position verschieben
        - häufiger Anwendung ist allerdings eine Vorfahrekontainerelement für
            absolute Elemente zu erzeugen
        - `absolute`
            - relative zu einem nonstatic Vorfahren positioniert
                - auch über top, bottom, left und right
            - findet ein absolutes Elementen keinen non static Vorfahren, dann
                orientiert es sich am Viewport
        - `fixed`
            - top, bottom, left und right können wir elemente relative zum Viewport positionieren 
            - dabei wird das Element aus dem Dokumentenfluss rausgenommen
            - selbst beim scrollen bleibt diese Positionierung erhalten
        - `sticky`
            - zunächst bleibt es wie gewöhnlich im Dokumentfluss positioniert
            - erst wenn der Elternkontainer vom Viewport verschwindet bzw
                der top wert vom stickyelement erreicht wird, dann wird es fixiert
            - und erst wenn die Elternbox komplet aus dem Viewport verschwindet, erst dann verschwindet auch das sticky Element 
                static (default)
        - Reihenfolge, in der Html Elemente vom Browser gemalt werden
            (die Reihenfolge der Überlappung)
        - wird bestimmt durch
            - z-index
            - DOM-Reihenfolge (wann das Element im Html auftaucht)
            - Positionierungsart der Element (static Elemente werden als erstes gemalt, dann werden non-static Elemente gemalt)


![z-index und stacking Kontext](<shapes at 25-11-24 09.38.30.svg>)      

4. Mobile First

- wir fangen mit dem Design für kleine Bildschirmgrößen an
    - dabei fokusieren uns auf den wesentlichen Inhalt, da der Platz 
        - stark Eingeschränkt ist
- ein Herunterskalieren von großem Layout zu kleinem Layout oftmals scheitert
- das Design für kleine Bildschirme bildet das Grunddesign und 
    - größere Bildschirm bekommen zusätzlich Funktionen
- weniger Code-Duplikation und weniger css-Eigenschaften werden überschrieben
    - das verbessert die Performance und somit die Ladenzeiten
    - Suchmaschinen bevorzugen mobile-optimierte Seiten
- Einfachere Wartung
- die Barrierefreiheit verbessert sich, da wir eine klare und reduzierter
    Struktur erhalten

## Media Queries

### Nächster Schritt: Desktop-/Medium-Menü aufbauen


Zwei Aufgaben:

1. **Dropdown-Logik entfernen**

    * Menü soll immer sichtbar sein
    * Hamburger-Button wird ausgeblendet

2. **Vertikales Menü → horizontales Menü**

   * Menülinks nebeneinander statt untereinander

```css
@media (min-width: 35em) {
  .menu-toggle {
    display: none;
    /* Hides toggle button */
  }

  .menu-dropdown {
    display: block;
    position: static;
    /* Reveals the dropdown contents + overrides absolute positioning */
  }
}

@media (min-width: 35em) {
  .nav-menu {
    display: flex;
    border: 0;
    padding: 0 1em;
    /* Changes the menu to a flex container */
  }

  .nav-menu > li {
    flex: 1;
    /* Allows items to grow to fill the screen width */
  }

  .nav-menu > li + li {
    border: 0;
  }

  .nav-menu > li > a {
    padding: 0.3em;
    text-align: center;
  }
}
```

* Mobiles Menü hatte viele komplexe Styles (absolute Positionierung, Dropdown-Logik, Icon-Hack)
* Für größere Screens braucht man **nur wenige Overrides**, um wieder ein **statisches, normales Menü** zu erhalten

* `position: static` macht Eigenschaften wie `top`, `left`, `right` wirkungslos
  → daher müssen diese **nicht überschrieben** werden

* **Flexbox** eignet sich ideal:

  * `display: flex` auf `.nav-menu`
  * `flex: 1` auf jedem `li`
    → Items teilen sich den verfügbaren Platz gleichmäßig

* Padding der Menü-Links wird reduziert

* Ergebnis:

    * kleines Gerät → vertikales, toggelbares Dropdown
    * mittleres Gerät → horizontales, immer sichtbares Menü

    * mobile-first Styles → minimal überschrieben, saubere CSS-Struktur

### responsive Spalten hinzugfügen

- Umsetzung mit Flexbox 
Layout **nur ab 35em aktivieren** → darunter bleibt alles einspaltig

* Die HTML-Struktur war schon vorbereitet:

  * `.row` umschließt die Spalten
  * jede Spalte hat `.column`

* In der Media Query wird:

  * `.row` → **flex container**
  * `.column` → **gleichmäßige Breite** (`flex: 1`)

* Ergebnis:

  * Mobil: einspaltiges Layout
  * Medium und größer: mehrspaltig
  * folgt konsequent dem **Mobile-First-Prinzip**

```css
@media (min-width: 35em) {
    .row {
        display: flex;
        border: #000 1px solid;

        margin-left: -.075em;
        margin-right: -.075em;
    }

    .column {
        flex: 1;
        margin-left: 0.75em;
        margin-right: 0.75em;
    }
}
```

* Breakpoints sollten **visuell begründet** sein, nicht willkürlich

* Ressourcen: Brad Frosts Sammlung von Responsive-Patterns

 * verschiedene Layout-Varianten: 1–3 Spalten, asymmetrisch, equal-width usw.
  *  https://bradfrost.github.io/this-is-responsive/patterns.html. 


* Oft braucht man **nicht einmal Media Queries**:

* **Flexbox + `flex-wrap: wrap` + `flex-basis`** → Items brechen natürlich um

 * **inline-block** funktioniert theoretisch auch, aber füllt Breite nicht automatisch auf

## Fluid layouts

* **Fluid (liquid) Layout** = Container passen sich **dynamisch** an die Viewport-Breite an

* Gegensatz zu **fixed layout** (z. B. `width: 800px` → führt zu horizontalem Scrollen auf kleinen Screens)

* Hauptcontainer in fluid Layouts:

  * haben **keine feste Breite**
  * oder nutzen **Prozentwerte**
  * oft mit **Padding** oder **auto-Margins**, damit Inhalt nicht am Rand klebt

  * sind immer **gleich oder kleiner** als der Viewport, aber niemals breiter

* Spalten in fluid Layouts:

  * sollten **prozentuale Breiten** nutzen, z. B.

    * Main: 70%
    * Sidebar: 30%
* passen sich dadurch an jede mögliche Breite an

* Flexbox funktioniert ebenfalls fluid, **wenn**

  * `flex-grow` erlaubt Wachstum
  * `flex-shrink` das Schrumpfen zulässt

* Zentrale Regel:
  → **In Prozenten denken – nicht in fixen Pixeln**

### Adding styles for a large viewport

```css
@media (min-width: 50em) {
    .page-header {
        padding: 1em 4em
    }

    .hero {
        padding: 7em 6em;
    }

    .main {
        padding: 2em 4em;
    }

    .nav-menu {
        padding: 0 4em;
    }
```

**großzügiges Padding** für alle Hauptbereiche
* Ziel: Layout wirkt luftiger, nicht gequetscht, nutzt den breiten Screen optimal

* Die Basis-Schriftgröße stammt aus

  ```css
  :root { font-size: calc(1vw + 0.6em); }
  ```
* sie wächst **mit jeder Vergrößerung des Viewports**.

* Auf **großen Screens** wird diese flüssige Schriftgröße **zu groß**.

Lösung: Am **höchsten Breakpoint** (z. B. `min-width: 50em`) eine **Obergrenze** setzen.

```css
:root {
  box-sizing: border-box;
  font-size: calc(1vw + 0.6em);
}

@media (min-width: 50em) {
  :root {
    font-size: 1.125em;
    /* caps the fluid font size on large viewports */
  }
}
```

### Tabelle

* Tabellen sind **schwierig** in fluiden Layouts
* Viele Spalten → Tabelle wird **breiter als der Bildschirm**

* **Bessere Alternativen**, wenn möglich:

  * Jede Tabellenzeile als **eigene Kachel/Tile** darstellen → stacked Cards

 * Daten als **Diagramm/Grafik** visualisieren
 * Informationen **untereinander** statt nebeneinander strukturieren

* **Aber**: manchmal braucht man trotzdem eine Tabelle.

* Eine Lösung dafür:
  → Tabelle in **block-level Elemente** umwandeln, sodass jede Zelle untereinander angezeigt wird

Beispiel-Idee:

* Jeder `<tr>` wird ein Block
* Jede `<td>` ein Block

* Labels können per CSS hinzugefügt werden


## Responsive Images

* Bilder brauchen im Responsive Design **besondere Behandlung*


### img mit srcset

* **Media Queries** funktionieren gut für Bilder, die per **CSS als Hintergrund** eingebunden sind.

* Für Bilder im HTML, also `<img>`, braucht man jedoch einen anderen Mechanismus.


* Lösung: **`srcset`** (Source Set)

* erlaubt mehrere Bildversionen für ein einziges `<img>`
* jede Version erhält eine Angabe wie `400w`, `800w`, `1200w`
