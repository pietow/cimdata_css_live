# 15. Multimedia in HTML & KI - Prompt engineering

> Lernziele
> - verschiedene Video-Formate
> - video und source tag
> - (Standart-)Einstellungen von Videos in Html
> - Erstellung von verschiedenen Untertiteln 
> - Alternative zu video tag: youtube Einbettung
> - audio
> - KI
> - Prompt engineering
>   - Formulierung und Verbesserung eines Prompts (Anweisung für LLM Modele (Bsp. Chatgpt, Claude, Bard, Gemini))
> - Git-Copilot
> - Bsp. in Chatgpt  

**Wiederholung**

- Javascript
    - Skriptsprache
    - entweder in skripttag schreiben oder über externe js-Datei einbinden

```html
....

<!-- Variante 1 -->
<script>
    let msg
    msg = 'Hello World'
    const PI = 3.14
    console.log(msg)
</script>
<!-- Variante 2 -->
<script src="hello.js"></script>

```

- variablen in js deklarieren:
    - wir können mit let, var und const variablen deklarieren
    - let vs. const
        - let variablen können ihren Wert ändern
        - const Variablen bleiben konstant; Wertänderungen führen zu einem Fehler im Programm
    - Werte in der Konsole ausprinten bzw. ausgeben:
        `console.log()`
    - `console.log()` für Entwickler relevant, um z.b. Wert zu überprüfen und um zu debuggen
        - `console.warn()` für Warnung
        - `console.error()` für Fehler
- Dialogboxen:
    - `alert(Hallo)`
    - `confirm(Msg)`
    - `prompt()`
- verschiedene Datentypen:
    - Zeichenketten (String)
    - Number
    - Boolean

- wie kann elemente in js auswählen


## HTML video-Element 

* Video im Browser ohne Plugins abspielbar.
* Alle modernen Browser unterstützen `<video>`.

### Formate

* MP4: weit verbreitet; hohe Qualität; kleine Dateigröße; mobil bevorzugt.
* WebM: gute Kompression; gut bei Vidoes mit viel Bewegung.


* Browser unterstützten WebM früh.
* WebM wurde im Web immer üblicher.
* YouTube setzt inzwischen auf WebM.


* `<video>` kann direkt per `src` ein einzelnes Video laden.
* Für maximale Kompatibilität mehrere `<source>`-Elemente verwenden.

```html
<body>
    <video width="720" src="mein_video-webm">
        Ihr Webbrowser unterstützt das video-Tag nicht
    </video>
</body>
```

**Beispiel 2 – Mehrere Formate (source-Elemente)**


```html
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mehrere Videoformate</title>
</head>
<body>
    <video width="720" controls autoplay>
        <source src="video/schrodinger.webm" type="video/webm">
        <source src="video/schrodinger.mp4" type="video/mp4">
        Ihr Webbrowser unterstützt das video-Tag nicht.
    </video>
</body>
</html>
```

#### Videoformat-Priorität bei `<source>`**

**Funktionsweise**

* Browser prüft die `<source>`-Elemente von oben nach unten.
* Erstes unterstütztes Format wird geladen und abgespielt.
* Weitere Formate werden ignoriert.

**Priorisierung**

* Bevorzugtes Format muss als erstes `<source>` direkt unter `<video>` stehen.
* Reihenfolge = Priorität.



#### **Attribute von `<video>`**

* `controls`
  * Zeigt Steuerelemente wie Play/Pause/Volume.
* `autoplay`
  * Startet das Video automatisch nach dem Laden.
  * Browser blockieren autoplay mit Ton.
    * Das Video muss stummgestellt werden.
* `loop`
  * Spielt das Video nach dem Ende erneut ab.
* `muted`
  * Startet stumm (häufig erforderlich für autoplay). 

### **Untertitel mit `<track>`**

**Zweck**

* Zusätzliche Textspuren für Videos und Audios.
* Untertitel, Übersetzungen, Transkripte, Barrierefreiheit (gehörlos/schwerhörig).
* Inhalt ist separat, nicht Teil des Video-/Audiostreams.

**Dateiformat**

* WebVTT (`.vtt`) ist der Standard für HTML5-Untertitel.

**Wichtige Attribute**

* `src="..."` → Pfad zur `.vtt`-Datei.
* `kind="subtitles"` → Untertitelspur.
* `srclang="de"` → Sprachkennung.
* `label="Deutsch"` → Titel in der UI.
* `default` → Spur wird automatisch aktiviert.

**Einschränkungen**
* Songtexte oft urheberrechtlich geschützt.

**Vollständiges HTML-Beispiel**

```html
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video mit Untertiteln</title>
</head>
<body>
    <video width="480" controls>
        <source src="video/Schrodinger.webm" type="video/webm">
        <track
            default
            src="untertitel.vtt"
            kind="subtitles"
            srclang="de"
            label="Deutsch"
        >
        <track
            src="untertitel_en.vtt"
            kind="subtitles"
            srclang="en"
            label="Englisch"
        >
        Ihr Webbrowser unterstützt das video-Tag nicht.
    </video>
</body>
</html>
```

**YouTube-Videos einbinden**

**Warum YouTube nutzen**

* Kein eigener Traffic für große Videodateien.
* Sehr kompatibel auf allen Geräten.

#### **Einbindungsmöglichkeiten**

* `<iframe>` ( Standard)
* `<object>` 
* `<embed>` 


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <iframe width="400"
            height="225"
            src="https://www.youtube-nocookie.com/embed/H8OYVuyBSNA" 
            allowfullscreen
     ></iframe>
    
</body>
</html>
```

**DSGVO beim Einbetten von YouTube-Videos**

**Problem**
* Beim Start eines eingebetteten YouTube-Videos werden personenbezogene Daten übertragen.
* Betroffen: IP-Adresse, Cookies, Geräteinformationen.
* Ohne Einwilligung ist das datenschutzrechtlich problematisch.

* `youtube-nocookie.com` verwenden (reduziert, aber verhindert Cookies nicht vollständig)
* Video erst nach Einwilligung laden (Cookie-Banner / Consent-Tool).

* Übersicht und Lösungen: [https://webmasterin.net/youtube-videos-dsgvo/](https://webmasterin.net/youtube-videos-dsgvo/)


## **Audio**

**Formate**

* MP3: von allen modernen Browsern unterstützt; geeignet für Web.
* OGG (Vorbis): offen, lizenzfrei; gute Alternative.
* WAV: sehr große Dateien; selten sinnvoll für Web.


**Funktionsweise**

* Aufbau identisch zu `<video>`.
* Fallback-Text zwischen `<audio>` und `</audio>`.
* Mehrere `<source>`-Elemente für maximale Kompatibilität.
* Browser spielt das erste unterstützte Format ab.


```html
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio abspielen</title>
</head>
<body>
    <audio controls>
        <source src="sound/Hallo.ogg" type="audio/ogg">
        <source src="sound/Hallo.mp3" type="audio/mpeg">
        Dieser Webbrowser unterstützt das audio-Tag nicht.
    </audio>
</body>
</html>
```

# Prompt engineerin - KI effizient verwenden

* Grundlage für Prompt-Entwicklung für Sprachmodelle.
* Prompt-Strukturen
* systematisch präzise Prompts erstellen.
* Nutzung von Tools wie ChatGPT für automatisierte Inhaltserstellung.


### LLM-Prompts
* LLMs verarbeiten und erzeugen natürliche Sprache.
* Ziel: kohärente, kontextnahe und menschenähnliche Antworten.

* neuronalen Netzwerkarchitekturen
*  Modell gewichtet relevante Wörter im Kontext.


* Training hat zwei Phasen: Vortraining und Feinabstimmung.

### Vortraining

* Modell erhält große Textmengen aus vielen Quellen.
* Ziel: Muster der Sprache erkennen.
* Texte werden in kleinere Einheiten zerlegt („Chunking“).

### Tokenisierung

* Sätze werden in Tokens zerlegt: Wörter, Wortteile, Sonderzeichen.
* 1 Wort = 1 Token oder 1 Wort = mehrere Tokens sein
* Durchschnittlich entsprechen 1.000 Tokens etwa 700–800 Wörtern im Englischen.

* Jeder Token wird in einen Zahlenvektor übersetzt.


### Feinabstimmung (Fine-tuning)

* Nach dem Vortraining folgt spezielles Training auf kleineren, zielgerichteten Datensätzen.
* Modell lernt anhand beschrifteter Beispieldaten.


### Nutzung nach dem Training

* Bei neuen Prompts kombiniert das Modell Muster aus Vortraining und Feinabstimmung.
* durch Mustererkennung  werden imitiert

### Bedeutung des Kontextfensters

* Kontextfenster bestimmt, wie viel Text das Modell gleichzeitig berücksichtigen kann.

### Kategorien von LLM-Prompts

* Prompts lassen sich nach Zweck, Format und Informationsmenge einteilen.

### Zero-shot-Prompting

Eingabe *„Write a poem about love“*

### Fine-tuning

* Modell wird mit kleinen, beschrifteten Beispieldaten für eine konkrete Aufgabe nachtrainiert.
* Liefert oft qualitativere Ergebnisse, benötigt jedoch ausreichend gelabelte Daten.
* über eine API kann ein Fine-Tuning-Training gestartet 

### Data-Augmentation-Prompts

* Trainingsdaten werden künstlich erweitert (Synonyme, Paraphrasen, Tippfehler).

Prompt:
„Erzeuge 20 Varianten dieses Satzes mit Synonymen und paraphrasiert: ‚Das Wetter ist heute sonnig und warm.‘“

Output kann enthalten:

* Heute wirkt das Wetter richtig warm und sonnig.
* Heit scheint die Sonne stark, es ist angenehm warm.
* Das Weter ist sonnich und richtig warm.
* usw.

### Active Learning / Few-Shot Learning

* Modell erhält wenige beschriftete Beispiele.
* Nutzer gibt Musterbeispiele vor, z. B. gewünschtes Ausgabeformat wie JSON.

### Role Prompting

* Nutzer oder Modell übernehmen eine definierte Rolle oder Persona.
* Ziel: relevantere, kontextgerechte und präzisere Antworten.
* Rolle beeinflusst Ton, Expertise und Perspektive der Ausgabe.
* Geeignet für spezifische Fachgebiete oder interaktive Szenarien.


## Code-Generierung mit KI-Assistenten

* Moderne Tools wie **GPT-4** erzeugen funktionsfähigen Code aus kurzen Anweisungen.
* Unterstützen **automatisch modulare, integrierte Codeblöcke**.
* Deutlich **schnellere Entwicklungszyklen**, steigert Produktivität.
* Routineaufgaben werden automatisiert

## Beispiel: Boilerplate für HTML/CSS generieren